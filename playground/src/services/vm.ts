/**
 * NanoCore VM Service
 * Wrapper around the WebAssembly module for easy use in React
 */

// @ts-ignore - Will be generated by build script
import NanoCoreWASM from '/nanocore-mock.js'

export interface VMState {
  pc: bigint
  sp: bigint
  flags: bigint
  registers: bigint[]
  vregisters: bigint[][]
  perfCounters: bigint[]
  halted: boolean
}

export interface StepResult {
  halted: boolean
  error?: string
  event?: { type: string; data: number }
}

export class NanoCoreVM {
  private module: any
  private handle: number = 0
  private memorySize: number

  constructor(module: any, handle: number, memorySize: number) {
    this.module = module
    this.handle = handle
    this.memorySize = memorySize
  }

  static async create(memorySize: number = 64 * 1024 * 1024): Promise<NanoCoreVM> {
    const module = await NanoCoreWASM()
    
    // Initialize the library
    const initResult = module._nanocore_init()
    if (initResult !== 0) {
      throw new Error(`Failed to initialize NanoCore: ${initResult}`)
    }

    // Create VM instance
    const handlePtr = module._malloc(4)
    const createResult = module._nanocore_vm_create(memorySize, handlePtr)
    
    if (createResult !== 0) {
      module._free(handlePtr)
      throw new Error(`Failed to create VM: ${createResult}`)
    }

    const handle = module.getValue(handlePtr, 'i32')
    module._free(handlePtr)

    return new NanoCoreVM(module, handle, memorySize)
  }

  async reset(): Promise<void> {
    const result = this.module._nanocore_vm_reset(this.handle)
    if (result !== 0) {
      throw new Error(`Failed to reset VM: ${result}`)
    }
  }

  async loadProgram(program: Uint8Array, address: number = 0x10000): Promise<void> {
    const dataPtr = this.module._malloc(program.length)
    this.module.HEAPU8.set(program, dataPtr)

    const result = this.module._nanocore_vm_load_program(
      this.handle,
      dataPtr,
      program.length,
      address
    )

    this.module._free(dataPtr)

    if (result !== 0) {
      throw new Error(`Failed to load program: ${result}`)
    }
  }

  async step(): Promise<StepResult> {
    const result = this.module._nanocore_vm_step(this.handle)
    
    // Check for events
    const eventTypePtr = this.module._malloc(4)
    const eventDataPtr = this.module._malloc(8)
    const eventResult = this.module._nanocore_vm_poll_event(
      this.handle,
      eventTypePtr,
      eventDataPtr
    )

    let event
    if (eventResult === 0) {
      event = {
        type: this.module.getValue(eventTypePtr, 'i32'),
        data: this.module.getValue(eventDataPtr, 'i64')
      }
    }

    this.module._free(eventTypePtr)
    this.module._free(eventDataPtr)

    return {
      halted: result === 0,
      error: result < 0 ? `Error code: ${result}` : undefined,
      event
    }
  }

  async run(maxInstructions: number = 0): Promise<StepResult> {
    const result = this.module._nanocore_vm_run(this.handle, maxInstructions)
    
    return {
      halted: result === 0,
      error: result < 0 ? `Error code: ${result}` : undefined
    }
  }

  async getState(): Promise<VMState> {
    const stateSize = 8 + 8 + 8 + (32 * 8) + (16 * 4 * 8) + (8 * 8) + 8 + 8
    const statePtr = this.module._malloc(stateSize)

    const result = this.module._nanocore_vm_get_state(this.handle, statePtr)
    if (result !== 0) {
      this.module._free(statePtr)
      throw new Error(`Failed to get state: ${result}`)
    }

    let offset = 0
    const pc = this.module.getValue(statePtr + offset, 'i64'); offset += 8
    const sp = this.module.getValue(statePtr + offset, 'i64'); offset += 8
    const flags = this.module.getValue(statePtr + offset, 'i64'); offset += 8

    const registers: bigint[] = []
    for (let i = 0; i < 32; i++) {
      registers.push(this.module.getValue(statePtr + offset, 'i64'))
      offset += 8
    }

    const vregisters: bigint[][] = []
    for (let i = 0; i < 16; i++) {
      const vreg: bigint[] = []
      for (let j = 0; j < 4; j++) {
        vreg.push(this.module.getValue(statePtr + offset, 'i64'))
        offset += 8
      }
      vregisters.push(vreg)
    }

    const perfCounters: bigint[] = []
    for (let i = 0; i < 8; i++) {
      perfCounters.push(this.module.getValue(statePtr + offset, 'i64'))
      offset += 8
    }

    this.module._free(statePtr)

    return {
      pc,
      sp,
      flags,
      registers,
      vregisters,
      perfCounters,
      halted: (flags & 0x80n) !== 0n
    }
  }

  async getRegister(index: number): Promise<bigint> {
    if (index < 0 || index >= 32) {
      throw new Error(`Invalid register index: ${index}`)
    }

    const valuePtr = this.module._malloc(8)
    const result = this.module._nanocore_vm_get_register(this.handle, index, valuePtr)
    
    if (result !== 0) {
      this.module._free(valuePtr)
      throw new Error(`Failed to get register: ${result}`)
    }

    const value = this.module.getValue(valuePtr, 'i64')
    this.module._free(valuePtr)
    
    return value
  }

  async setRegister(index: number, value: bigint): Promise<void> {
    if (index < 0 || index >= 32) {
      throw new Error(`Invalid register index: ${index}`)
    }

    const result = this.module._nanocore_vm_set_register(this.handle, index, value)
    if (result !== 0) {
      throw new Error(`Failed to set register: ${result}`)
    }
  }

  async readMemory(address: number, size: number): Promise<Uint8Array> {
    const bufferPtr = this.module._malloc(size)
    const result = this.module._nanocore_vm_read_memory(
      this.handle,
      address,
      bufferPtr,
      size
    )

    if (result !== 0) {
      this.module._free(bufferPtr)
      throw new Error(`Failed to read memory: ${result}`)
    }

    const data = new Uint8Array(size)
    data.set(this.module.HEAPU8.subarray(bufferPtr, bufferPtr + size))
    this.module._free(bufferPtr)

    return data
  }

  async writeMemory(address: number, data: Uint8Array): Promise<void> {
    const dataPtr = this.module._malloc(data.length)
    this.module.HEAPU8.set(data, dataPtr)

    const result = this.module._nanocore_vm_write_memory(
      this.handle,
      address,
      dataPtr,
      data.length
    )

    this.module._free(dataPtr)

    if (result !== 0) {
      throw new Error(`Failed to write memory: ${result}`)
    }
  }

  async getPerfCounter(counter: number): Promise<bigint> {
    const valuePtr = this.module._malloc(8)
    const result = this.module._nanocore_vm_get_perf_counter(
      this.handle,
      counter,
      valuePtr
    )

    if (result !== 0) {
      this.module._free(valuePtr)
      throw new Error(`Failed to get performance counter: ${result}`)
    }

    const value = this.module.getValue(valuePtr, 'i64')
    this.module._free(valuePtr)

    return value
  }

  destroy(): void {
    if (this.handle !== 0) {
      this.module._nanocore_vm_destroy(this.handle)
      this.handle = 0
    }
  }
}